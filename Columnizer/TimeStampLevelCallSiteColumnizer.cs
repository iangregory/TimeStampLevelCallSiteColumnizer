namespace LogExpert
{
    using System;
    using System.Globalization;
    /// <summary>
    /// Columnizer supporting a five column format containing timestamp, log level, call site and log entry.
    ///  A suitable log format can be generated by nLog using the layout: 
    ///  ${longdate} ${level:uppercase=true} ${pad:padding=-65:alignmentOnTruncation=right:fixedlength=true:${callsite:className=true:includeSourcePath=false:methodName=true:cleanNamesOfAnonymousDelegates=true}}: ${message}
    /// </summary>
    /// <seealso cref="LogExpert.ILogLineColumnizer" />
    public class TimeStampLevelCallSiteColumnizer : ILogLineColumnizer
    {
        private int timeOffset = 0;
        private readonly string dateFormat = "yyyy-MM-dd";
        private readonly string timeFormat = "HH:mm:ss.ffff";
        private string dateTimeFormat => dateFormat + " " + timeFormat;

        /// <summary>
        /// Sets an offset to be used for displaying timestamp values. 
        /// </summary>
        /// <param name="msecOffset">The timestamp offset in milliseconds.</param>
        public void SetTimeOffset(int msecOffset)
        {
            this.timeOffset = msecOffset;
        }

        /// <summary>
        /// Returns the current stored timestamp offset (set by SetTimeOffset()).
        /// </summary>
        /// <returns>
        /// The current stored timestamp offset (set by SetTimeOffset()).
        /// </returns>
        public int GetTimeOffset() => this.timeOffset;

        /// <summary>
        /// Returns the timestamp value of the given line as a .NET DateTime object. If there's no valid timestamp in the
        /// given line, return DateTime.MinValue.
        /// </summary>
        /// <param name="callback">Callback interface with functions which can be used</param>
        /// <param name="line">The line content which timestamp has to be returned.</param>
        /// <returns>The timestamp</returns>
        public DateTime GetTimestamp(ILogLineColumnizerCallback callback, string line)
        {
            try
            {
                // Check to see if we have a space where we expect it - if not, return early without trying to parse the date
                if (line.Length < dateTimeFormat.Length || line.Length > dateTimeFormat.Length && line[dateTimeFormat.Length] != ' ')
                {
                    return DateTime.MinValue;
                }

                var dateTimeStr = line.Substring(0, dateTimeFormat.Length);

                return DateTime.ParseExact(dateTimeStr, dateTimeFormat, CultureInfo.InstalledUICulture);
            }
            catch (Exception)
            {
                return DateTime.MinValue;
            }
        }

        /// <summary>
        /// This function is called if the user changes a value in a column (edit mode in the log view).
        /// The purpose of the function is to determine a new timestamp offset. So you have to handle the
        /// call only if the given column displays a timestamp.
        /// </summary>
        /// <param name="callback">Callback interface with functions which can be used</param>
        /// <param name="column">The column number which value has changed.</param>
        /// <param name="value">The new value.</param>
        /// <param name="oldValue">The old value.</param>
        public void PushValue(ILogLineColumnizerCallback callback, int column, string value, string oldValue)
        {
            if (column == 1)
            {
                try
                {
                    var newDateTime = DateTime.ParseExact(value, timeFormat, CultureInfo.InstalledUICulture);
                    var oldDateTime = DateTime.ParseExact(oldValue, timeFormat, CultureInfo.InstalledUICulture);
                    var msecsOld = oldDateTime.Ticks / TimeSpan.TicksPerMillisecond;
                    var msecsNew = newDateTime.Ticks / TimeSpan.TicksPerMillisecond;
                    this.timeOffset = (int)(msecsNew - msecsOld);
                }
                catch (FormatException)
                {
                }
            }
        }

        /// <summary>
        /// Returns the name. 
        /// </summary>
        /// <returns>Returns the name</returns>
        public string GetName() => "Timestamp, Log Level and Call Site Columnizer";

        /// <summary>
        /// Returns the name. 
        /// </summary>
        public string Text => GetName();        

        /// <summary>
        /// Returns the description. 
        /// </summary>
        /// <returns>Returns the description</returns>
        public string GetDescription() => 
             "Splits every line into 5 fields: Date, Time, Log Level, Call Site and the rest of the log message." + Environment.NewLine + Environment.NewLine +
             "Assumes a log level length of 4 characters and a call site length of 65.";

        /// <summary>
        /// The number of columns to split lines into. 
        /// </summary>
        /// <returns>Returns the number of columns we will split lines into. </returns>
        public int GetColumnCount() => 5;

        /// <summary>
        /// The names of the columns. The returned names are used by LogExpert for the column headers in the data grid view.
        /// The names are expected in order from left to right. 
        /// </summary>
        /// <returns>Returns the names of the columns.</returns>
        public string[] GetColumnNames() => new string[] { "Date", "Time", "Level", "Call Site", "Message" };

        /// <summary>
        /// Given a single line of the log file this function splits the line content into columns. The function returns 
        /// a string array containing the split content.
        /// </summary>
        /// <param name="callback">Callback interface with functions which can be used</param>
        /// <param name="line">The line content to be split</param>
        /// <returns>The parsed columns</returns>
        public string[] SplitLine(ILogLineColumnizerCallback callback, string line)
        {
            // 0         1         2         3         4         5         6         7         8         9         10        11        12        13        14        15        16
            // 012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789
            // 2016-03-20 19:03:30.8642 INFO Call Site                                                          : <rest of line>

            var endPos = dateTimeFormat.Length;
            var timeLen = timeFormat.Length;
            var dateLen = dateFormat.Length;
            var logEntryPrefixLen = 2;
            var cols = new string[5];

            // If the line is shorter than we expect, or doesn't contain a space delimiter where we expect it, don't attempt to parse it
            if (line.Length < 97 || line.Length > endPos && line[endPos] != ' ')
            {
                return new string[] { string.Empty, string.Empty, string.Empty, string.Empty, line };
            }

            try
            {
                if (this.timeOffset != 0)
                {
                    var dateTime = DateTime.ParseExact(line.Substring(0, endPos),dateTimeFormat, CultureInfo.CurrentUICulture);
                    dateTime = dateTime.Add(new TimeSpan(0, 0, 0, 0, this.timeOffset));
                    var newDate = dateTime.ToString(dateTimeFormat, CultureInfo.CurrentUICulture);
                    cols[0] = newDate.Substring(0, dateLen);                 // date
                    cols[1] = newDate.Substring(dateLen + 1, timeLen);       // time
                }
                else
                {
                    cols[0] = line.Substring(0, dateLen);                 // date
                    cols[1] = line.Substring(dateLen + 1, timeLen);       // time
                }

                // Find the space which delimits the end of the log level field
                var startIndex = dateLen + 1 + timeLen + 1;
                var logLen = line.IndexOf(' ', startIndex) - startIndex;                

                // Find the colon which delimits the call site field
                startIndex = dateLen + 1 + timeLen + 1 + logLen + 1;
                var callSiteLen = line.IndexOf(':', startIndex) - startIndex;

                if (logLen < 1 || callSiteLen < 1)
                {
                    return new string[] { string.Empty, string.Empty, string.Empty, string.Empty, line };
                }

                cols[2] = line.Substring(dateLen + 1 + timeLen + 1, logLen);  // log level
                cols[3] = line.Substring(dateLen + 1 + timeLen + 1 + logLen + 1, callSiteLen); // call site
                cols[4] = line.Substring(dateLen + 1 + timeLen + 1 + logLen + 1 + callSiteLen + logEntryPrefixLen);  // rest of line
            }
            catch (Exception)
            {
                return new string[] { string.Empty, string.Empty, string.Empty, string.Empty, line };
            }

            return cols;
        }

        /// <summary>
        /// Indicates whether we supports time shift handling.
        /// </summary>
        /// <returns>Returns true, if we support time shift handling.</returns>
        public bool IsTimeshiftImplemented() => true;
        
    }
}