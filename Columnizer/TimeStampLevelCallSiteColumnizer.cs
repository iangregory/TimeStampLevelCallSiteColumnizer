namespace LogExpert
{
    using System;
    using System.Globalization;

    /// <summary>
    /// Columnizer supporting a five column format containing timestamp, log level, call site and log entry.
    ///  A suitable log format can be generated by nLog using the layout: 
    ///  ${longdate} ${level:uppercase=true} ${pad:padding=-65:alignmentOnTruncation=right:fixedlength=true:${callsite:className=true:includeSourcePath=false:methodName=true:cleanNamesOfAnonymousDelegates=true}}: ${message}
    /// </summary>
    /// <seealso cref="LogExpert.ILogLineColumnizer" />
    public class TimeStampLevelCallSiteColumnizer : ILogLineColumnizer
    {
        private int timeOffset = 0;
        private FormatInfo formatInfo1 = new FormatInfo("dd.MM.yyyy", "HH:mm:ss.fff", new CultureInfo("de-DE"));
        private FormatInfo formatInfo2 = new FormatInfo("dd.MM.yyyy", "HH:mm:ss", new CultureInfo("de-DE"));
        private FormatInfo formatInfo3 = new FormatInfo("yyyy/MM/dd", "HH:mm:ss.fff", new CultureInfo("en-US"));
        private FormatInfo formatInfo4 = new FormatInfo("yyyy/MM/dd", "HH:mm:ss", new CultureInfo("en-US"));
        private FormatInfo formatInfo5 = new FormatInfo("yyyy.MM.dd", "HH:mm:ss.fff", new CultureInfo("de-DE"));
        private FormatInfo formatInfo6 = new FormatInfo("yyyy.MM.dd", "HH:mm:ss", new CultureInfo("de-DE"));
        private FormatInfo formatInfo7 = new FormatInfo("dd.MM.yyyy", "HH:mm:ss,fff", new CultureInfo("de-DE"));
        private FormatInfo formatInfo8 = new FormatInfo("yyyy/MM/dd", "HH:mm:ss,fff", new CultureInfo("en-US"));
        private FormatInfo formatInfo9 = new FormatInfo("yyyy.MM.dd", "HH:mm:ss,fff", new CultureInfo("de-DE"));
        private FormatInfo formatInfo10 = new FormatInfo("yyyy-MM-dd", "HH:mm:ss.fff", new CultureInfo("en-US"));
        private FormatInfo formatInfo11 = new FormatInfo("yyyy-MM-dd", "HH:mm:ss,fff", new CultureInfo("en-US"));
        private FormatInfo formatInfo12 = new FormatInfo("yyyy-MM-dd", "HH:mm:ss", new CultureInfo("en-US"));
        private FormatInfo formatInfo13 = new FormatInfo("dd MMM yyyy", "HH:mm:ss,fff", new CultureInfo("de-DE"));
        private FormatInfo formatInfo14 = new FormatInfo("dd MMM yyyy", "HH:mm:ss.fff", new CultureInfo("de-DE"));
        private FormatInfo formatInfo15 = new FormatInfo("dd MMM yyyy", "HH:mm:ss", new CultureInfo("de-DE"));
        private FormatInfo formatInfo16 = new FormatInfo("dd.MM.yy", "HH:mm:ss.fff", new CultureInfo("de-DE"));
        private FormatInfo formatInfo17 = new FormatInfo("yyyy-MM-dd", "HH:mm:ss:ffff", new CultureInfo("en-US"));
        private FormatInfo formatInfo18 = new FormatInfo("yyyy-MM-dd", "HH:mm:ss.ffff", new CultureInfo("en-US"));

        /// <summary>
        /// Sets an offset to be used for displaying timestamp values. 
        /// </summary>
        /// <param name="msecOffset">The timestamp offset in milliseconds.</param>
        public void SetTimeOffset(int msecOffset)
        {
            this.timeOffset = msecOffset;
        }

        /// <summary>
        /// Returns the current stored timestamp offset (set by SetTimeOffset()).
        /// </summary>
        /// <returns>
        /// The current stored timestamp offset (set by SetTimeOffset()).
        /// </returns>
        public int GetTimeOffset() => this.timeOffset;

        /// <summary>
        /// Returns the timestamp value of the given line as a .NET DateTime object. If there's no valid timestamp in the
        /// given line, return DateTime.MinValue.
        /// </summary>
        /// <param name="callback">Callback interface with functions which can be used</param>
        /// <param name="line">The line content which timestamp has to be returned.</param>
        /// <returns>The timestamp</returns>
        public DateTime GetTimestamp(ILogLineColumnizerCallback callback, string line)
        {
            var cols = this.SplitLine(callback, line);
            if (cols == null || cols.Length < 2 || cols[0].Length == 0 || cols[1].Length == 0)
            {
                return DateTime.MinValue;
            }

            var formatInfo = this.DetermineDateTimeFormatInfo(line);
            if (formatInfo == null)
            {
                return DateTime.MinValue;
            }

            try
            {
                return DateTime.ParseExact(cols[0] + " " + cols[1], formatInfo.DateTimeFormat, formatInfo.CultureInfo);
            }
            catch (Exception)
            {
                return DateTime.MinValue;
            }
        }

        /// <summary>
        /// This function is called if the user changes a value in a column (edit mode in the log view).
        /// The purpose of the function is to determine a new timestamp offset. So you have to handle the
        /// call only if the given column displays a timestamp.
        /// </summary>
        /// <param name="callback">Callback interface with functions which can be used</param>
        /// <param name="column">The column number which value has changed.</param>
        /// <param name="value">The new value.</param>
        /// <param name="oldValue">The old value.</param>
        public void PushValue(ILogLineColumnizerCallback callback, int column, string value, string oldValue)
        {
            if (column == 1)
            {
                try
                {
                    var formatInfo = this.DetermineTimeFormatInfo(oldValue);
                    if (formatInfo == null)
                    {
                        return;
                    }

                    var newDateTime = DateTime.ParseExact(value, formatInfo.TimeFormat, formatInfo.CultureInfo);
                    var oldDateTime = DateTime.ParseExact(oldValue, formatInfo.TimeFormat, formatInfo.CultureInfo);
                    var msecsOld = oldDateTime.Ticks / TimeSpan.TicksPerMillisecond;
                    var msecsNew = newDateTime.Ticks / TimeSpan.TicksPerMillisecond;
                    this.timeOffset = (int)(msecsNew - msecsOld);
                }
                catch (FormatException)
                {
                }
            }
        }

        /// <summary>
        /// Returns the name. 
        /// </summary>
        /// <returns>Returns the name</returns>
        public string GetName() => "Timestamp, Log Level and Call Site Columnizer";

        /// <summary>
        /// Returns the description. 
        /// </summary>
        /// <returns>Returns the description</returns>
        public string GetDescription() => 
             "Splits every line into 5 fields: Date, Time, Log Level, Call Site and the rest of the log message." + Environment.NewLine + Environment.NewLine +
             "Assumes a log level length of 4 characters and a call site length of 65.";

        /// <summary>
        /// The number of columns to split lines into. 
        /// </summary>
        /// <returns>Returns the number of columns we will split lines into. </returns>
        public int GetColumnCount() => 5;

        /// <summary>
        /// The names of the columns. The returned names are used by LogExpert for the column headers in the data grid view.
        /// The names are expected in order from left to right. 
        /// </summary>
        /// <returns>Returns the names of the columns.</returns>
        public string[] GetColumnNames() => new string[] { "Date", "Time", "Level", "Call Site", "Message" };

        /// <summary>
        /// Given a single line of the log file this function splits the line content into columns. The function returns 
        /// a string array containing the split content.
        /// </summary>
        /// <param name="callback">Callback interface with functions which can be used</param>
        /// <param name="line">The line content to be split</param>
        /// <returns>The parsed columns</returns>
        public string[] SplitLine(ILogLineColumnizerCallback callback, string line)
        { 
            // 0         1         2         3         4         5         6         7         8         9         10        11        12        13        14        15        16
            // 012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789
            // 2016-03-20 19:03:30.8642 INFO Call Site                                                          : <rest of line>

            // If the line is shorter than we expect, don't attempt to parse it
            if (line.Length < 97)
            {
                return new string[] { string.Empty, string.Empty, string.Empty, string.Empty, line };
            }

            var formatInfo = this.DetermineDateTimeFormatInfo(line);
            
            // If we've not been able to decode the formating of the timestamp, bail out
            if (formatInfo == null)
            {
                return new string[] { string.Empty, string.Empty, string.Empty, string.Empty, line };
            }

            var endPos = formatInfo.DateTimeFormat.Length;
            var timeLen = formatInfo.TimeFormat.Length;
            var dateLen = formatInfo.DateFormat.Length;
            var logLen = 4;
            var callSiteLen = 65;
            var logEntryPrefixLen = 2;
            var cols = new string[5];

            try
            {
                if (this.timeOffset != 0)
                {
                    var dateTime = DateTime.ParseExact(line.Substring(0, endPos), formatInfo.DateTimeFormat, formatInfo.CultureInfo);
                    dateTime = dateTime.Add(new TimeSpan(0, 0, 0, 0, this.timeOffset));
                    var newDate = dateTime.ToString(formatInfo.DateTimeFormat, formatInfo.CultureInfo);
                    cols[0] = newDate.Substring(0, dateLen);                 // date
                    cols[1] = newDate.Substring(dateLen + 1, timeLen);       // time
                }
                else
                {
                    cols[0] = line.Substring(0, dateLen);                 // date
                    cols[1] = line.Substring(dateLen + 1, timeLen);       // time
                }

                cols[2] = line.Substring(dateLen + 1 + timeLen + 1, logLen);  // log level
                cols[3] = line.Substring(dateLen + 1 + timeLen + 1 + logLen + 1, callSiteLen); // call site
                cols[4] = line.Substring(dateLen + 1 + timeLen + 1 + logLen + 1 + callSiteLen + logEntryPrefixLen);  // rest of line
            }
            catch (Exception)
            {
                cols[0] = "n/a";
                cols[1] = "n/a";
                cols[2] = "n/a";
                cols[3] = "n/a";                
                cols[4] = line;
            }

            return cols;
        }

        /// <summary>
        /// Indicates whether we supports time shift handling.
        /// </summary>
        /// <returns>Returns true, if we support time shift handling.</returns>
        public bool IsTimeshiftImplemented() => true;

        /// <summary>
        /// Decode the timestamp format based on a log line entry
        /// </summary>
        /// <param name="line">The log line</param>
        /// <returns>The timestamp format</returns>
        protected FormatInfo DetermineDateTimeFormatInfo(string line)
        {
            // dirty hardcoded probing of date/time format (much faster than DateTime.ParseExact()
            if (line[2] == '.' && line[5] == '.' && line[13] == ':' && line[16] == ':')
            {
                if (line[19] == '.')
                {
                    return this.formatInfo1;
                }
                else if (line[19] == ',')
                {
                    return this.formatInfo7;
                }
                else
                {
                    return this.formatInfo2;
                }
            }
            else if (line[4] == '/' && line[7] == '/' && line[13] == ':' && line[16] == ':')
            {
                if (line[19] == '.')
                {
                    return this.formatInfo3;
                }
                else if (line[19] == ',')
                {
                    return this.formatInfo8;
                }
                else
                {
                    return this.formatInfo4;
                }
            }
            else if (line[4] == '.' && line[7] == '.' && line[13] == ':' && line[16] == ':')
            {
                if (line[19] == '.')
                {
                    return this.formatInfo5;
                }
                else if (line[19] == ',')
                {
                    return this.formatInfo9;
                }
                else
                {
                    return this.formatInfo6;
                }
            }
            else if (line[4] == '-' && line[7] == '-' && line[13] == ':' && line[16] == ':')
            {
                if (line[19] == '.')
                {
                    if (line[24] == ' ')
                    {
                        return this.formatInfo18;
                    }

                    return this.formatInfo10;
                }
                else if (line[19] == ',')
                {
                    return this.formatInfo11;
                }
                else if (line[19] == ':')
                {
                    return this.formatInfo17;
                }
                else
                {
                    return this.formatInfo12;
                }
            }
            else if (line[2] == ' ' && line[6] == ' ' && line[14] == ':' && line[17] == ':')
            {
                if (line[20] == ',')
                {
                    return this.formatInfo13;
                }
                else if (line[20] == '.')
                {
                    return this.formatInfo14;
                }
                else
                {
                    return this.formatInfo15;
                }
            }
            else if (line[2] == '.' && line[5] == '.' && line[11] == ':' && line[14] == ':' && line[17] == '.')
            {
                // dd.MM.yy HH:mm:ss.fff
                return this.formatInfo16;
            }

            return null;
        }

        /// <summary>
        /// Decode the timestamp format based on a log line entry
        /// </summary>
        /// <param name="field">The timestamp field</param>
        /// <returns>The timestamp format</returns>
        protected FormatInfo DetermineTimeFormatInfo(string field)
        {
            // dirty hardcoded probing of time format (much faster than DateTime.ParseExact()
            if (field[2] == ':' && field[5] == ':')
            {
                if (field.Length > 8)
                {
                    if (field[8] == '.')
                    {
                        return this.formatInfo1;
                    }
                    else if (field[8] == ',')
                    {
                        return this.formatInfo7;
                    }
                }
                else
                {
                    return this.formatInfo2;
                }
            }

            return null;
        }

        /// <summary>
        /// Helper class to store date/time formats
        /// </summary>
        protected class FormatInfo
        {
            /// <summary>
            /// Initializes a new instance of the <see cref="FormatInfo"/> class.
            /// </summary>
            /// <param name="dateFormat">The date format.</param>
            /// <param name="timeFormat">The time format.</param>
            /// <param name="cultureInfo">The culture information.</param>
            public FormatInfo(string dateFormat, string timeFormat, CultureInfo cultureInfo)
            {
                this.DateFormat = dateFormat;
                this.TimeFormat = timeFormat;
                this.CultureInfo = cultureInfo;
            }

            /// <summary>
            /// Gets the date format.
            /// </summary>
            /// <value>
            /// The date format.
            /// </value>
            public string DateFormat { get; }

            /// <summary>
            /// Gets the time format.
            /// </summary>
            /// <value>
            /// The time format.
            /// </value>
            public string TimeFormat { get; }

            /// <summary>
            /// Gets the culture information.
            /// </summary>
            /// <value>
            /// The culture information.
            /// </value>
            public CultureInfo CultureInfo { get; }

            /// <summary>
            /// Gets the date time format.
            /// </summary>
            /// <value>
            /// The date time format.
            /// </value>
            public string DateTimeFormat => this.DateFormat + " " + this.TimeFormat;
        }
    }
}